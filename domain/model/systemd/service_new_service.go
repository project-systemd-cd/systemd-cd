package systemd

import (
	"os"
	"reflect"
	"strings"
)

// NewService implements iSystemdService
func (s Systemd) NewService(name string, uf UnitFileService, env map[string]string) (UnitService, error) {
	// load unit file
	path := strings.Join([]string{s.unitFileDir, name, ".service"}, "")
	loaded, isGeneratedBySystemdCd, err := s.loadUnitFileSerivce(path)
	if err != nil && !os.IsNotExist(err) {
		// fail
		return UnitService{}, err
	}

	if os.IsNotExist(err) {
		// unit file not exists
		// generate `.service` file to `path`
		err = s.writeUnitFileService(uf, path)
	} else if isGeneratedBySystemdCd {
		// unit file already exists and file generated by systemd-cd
		if !loaded.Equals(uf) {
			// file has changes
			// update `.service` file to `path`
			err = s.writeUnitFileService(uf, path)
		}
	} else {
		// unit file already exists and file not generated by systemd-cd
		err = ErrUnitFileNotManaged
	}
	if err != nil {
		// fail
		return UnitService{}, err
	}

	if uf.Service.EnvironmentFile != nil {
		// load env file
		envPath := *uf.Service.EnvironmentFile
		loaded, isGeneratedBySystemdCd, err := s.loadEnvFile(envPath)
		if err != nil && !os.IsNotExist(err) {
			// fail
			return UnitService{}, err
		}

		if os.IsNotExist(err) {
			// unit file not exists
			// generate env file to `envPath`
			err = s.writeEnvFile(env, envPath)
		} else if isGeneratedBySystemdCd {
			// unit file already exists and file generated by systemd-cd
			if !reflect.DeepEqual(env, loaded) {
				// file has changes
				// update env file to `envPath`
				err = s.writeEnvFile(env, envPath)
			}
		} else {
			// unit file already exists and file not generated by systemd-cd
			err = ErrUnitEnvFileNotManaged
		}
		if err != nil {
			// fail
			return UnitService{}, err
		}
	}

	// daemon-reload
	err = s.systemctl.DaemonReload()

	return UnitService{s.systemctl, name, uf, path, env}, err
}
